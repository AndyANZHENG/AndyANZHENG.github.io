{"componentChunkName":"component---src-templates-handout-js","path":"/handout/functions","webpackCompilationHash":"18adea5e619a09c3c4b1","result":{"data":{"markdownRemark":{"rawMarkdownBody":"# Functions\n\n## Learning Objectives\n\n- Understand what functions are and what they are used for\n- Understand function scope\n\nFunctions are blocks of code that are designed to perform a particular task. Functions are reusable, when functions are executed we can say that they have been called or invoked, as functions are reusable it allows us to reduce the amount of code we write. This greatly reduces complexity, increases legibility and makes it a lot easier to maintain / update our code. Values can be passed into these functions and can be used within the function, when the function has finished executing it will return a value. (Within JavaScript, if a function has no return value then the function block will return undefined.\n\nTo use a function, you must define it somewhere in the scope where you wish to call it.\n\nA function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:\n\n- The name of the function.\n- A list of parameters to the function, enclosed in parentheses and separated by commas.\n- The JavaScript statements that define the function, enclosed in curly brackets, { }.\n\nThere are several ways to declare a function\n\n```js\nfunction functionName(parameter1, parameter2) {\n  //something happens\n}\n\n// Anonymous functions, functions without a name declaration\n\nvar functionName = function(parameter1, parameter2) {\n  // do something\n  // another anonymous function\n  function inner() {\n    // do something\n  }\n}\n```\n\nFor example, the following code defines a simple function named square:\n\n```js\nfunction square(number) {\n  return number * number\n}\n```\n\nAnother example, the following code defines a simple function named logger:\n\n```js\nfunction logger(a) {\n  console.log(a)\n}\n// the message needs to be passed into the function before it will console.log\n```\n\naddUp is another function, take a look below:\n\nTo call a function just invoke it by it’s name and add parameters if needed.\n\n```js\nfunction addUp(a, b, c) {\n  return a + b + c\n}\n\naddUp(1, 4, 6) // 11\n```\n\nIn the example above,addUp is the function object, while addUp() refers to the function result. Therefore invoking the function without () will not execute the function but instead return the functions definition.\n\nThe example of a function below utilizes the inbuilt alert() method of JavaScript:\n\n```js\nfunction alertBox(message) {\n  alert(message)\n}\n\nalertBox(\"Hello World\")\n\n// this code will force an alert box in our browser that will contain the message.\n```\n\nThe function above can be passed a string, number or boolean. The output will look similar to this:\n\n![alert_box](/ptcb/img/alert_box.png)\n\n## return\n\nNotice the `return` command in one of the functions above. As it’s name suggests it tells the function to give out a value. Without `return` the function never gives out the value of the multiplication\n\n```js\nfunction addUp(a, b) {\n  a + b\n}\naddUp(3, 5) // undefined\n```\n\nAdding a `return` statement ends the function as well. A function can only have one outcome and therefore only one `return` statement. Any code after a `return` statement will never run. However if you include conditions within a function, such as an `if` statement, the function can include several `return statements`.\n\n```js\nfunction isBiggerThanThree(a) {\n  if (a > 3) {\n    return true\n  } else {\n    return false\n  }\n\n  console.log(\n    \"I will never log to the console as the return statements above run before me\"\n  )\n}\n```\n\n## throw\n\nSometimes we encounter an error when running our functions. For example imagine the function expects a number as input, but instead receives a string. In that case we don’t want to return anything but instead tell the code that the input was wrong. For this we can use the `throw` statement.\n\nLike `return` `throw` stops the function from continuing to run, but tells the JavaScript console that something went wrong here and this problem needs to be dealt with.\n\n```js\nfunction multiply(n) {\n  if (isNaN(n)) {\n    throw new Error(\"Please enter a number\")\n  }\n  return n * 2\n}\n\nmultiply(\"bb\") // Error Please enter a number\n```\n\n## Scope\n\nScope defines where are variable can be accessed. In general we differentiate between `global` and `local` scope. Variables declared outside any functions are in the `global` scope, variables declared inside a function are in the `local` scope of that function. It is always possible to access `global` variables from a `local` scope but not the other way round.\n\n```js\nvar globalVariable = \"I'm so global\"\n\nfunction someFunction() {\n  var localVariable = \"I'm so local\"\n\n  function inner() {\n    var deeperNestedVariable = \"I'm nested in a function within a function\"\n    console.log(localVariable) // \"I'm so local\"\n    console.log(globalVariable) // \"I'm so global\"\n  }\n\n  console.log(globalVariable) // \"I'm so global\"\n  console.log(deeperNestedVariable) // Error\n}\n\nconsole.log(localVariable) // Error\n```\n\nFor more on scope watch Net Ninja’s [explanation](https://youtu.be/kjdZ1h3CIs4)\n\n## OPTIONAL READINGS\n\n---\n\n## Callbacks\n\nA callback function, also known as a higher-order function, is a function that is passed to another function (let’s call this other function “otherFunction”) as a parameter, and the callback function is called (or executed) inside the otherFunction. A callback function is essentially a pattern (an established solution to a common problem), and therefore, the use of a callback function is also known as a callback pattern.\n\nIn laymen's terms a callback is a function that will be executed after another function has finished\n\nIn the below example `setTimeout()` a JavaScript native function, calls the anonymous function after 1 second (1000 milliseconds)\n\n```js\nfunction begin() {\n  setTimeout(function() {\n    console.log(\"JS rocks!\")\n  }, 1000)\n}\n\nfunction middle() {\n  console.log(\"JS rocks my socks!\")\n}\n\nbegin()\n\nmiddle()\n\n// JS rocks my socks!\n\n// JS rocks!\n```\n\nDespite calling begin() first the console.log in middle() is executed first, this is due to the setTimeout function.\n\nCallbacks are a way to ensure certain code is executed only after other function have already finished executing.\n\n```js\nfunction getStock(stock) {\n  alert(`Getting the stock: \\${stock}.`)\n}\n\ngetStock(\"HSBC\")\n\n// Alerts: Getting the stock: HSBC\n```\n\nThe function getStock, is not a call back function, lets add a callback:\n\n```js\nfunction getStock(stock, callback) {\n  alert(`Getting the stock: ${stock}.`)\n\n  callback()\n}\n\ngetStock(\"HSBC\", function() {\n  alert(`Got the stock: ${stock}`)\n})\n\n// If you run the code above in the browser console you will get two alerts\n// the first 'Getting the stock', the second 'Got the stock'\n```\n\nBut you do not have to define the callback function when calling the original function, you can define the function elsewhere. Like below:\n\n```js\nfunction getStock(stock, callback) {\n  alert(`Getting the stock: ${stock}.`)\n\n  callback()\n}\n\nfunction gotStock(stock) {\n  alert(`Got stock: ${stock}`)\n}\n\ngetStock(\"HSBC\", gotStock(\"HSBC\"))\n```\n\nBonus Exercise\n\nThe function below is not working properly, can you fix it?\n\n```js\nfunction area(height width) {\n  height * width;\n}\n```\n"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"fileAbsolutePath":"/Users/Andy/Desktop/code/PROJECTS/xccelerate/ptcb-site/src/data/week_1/functions.html.turndown.md","title":"functions"}}}
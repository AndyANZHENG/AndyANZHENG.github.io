{"componentChunkName":"component---src-templates-handout-js","path":"/handout/es-6-standard","webpackCompilationHash":"8feccf555c07ef24ab95","result":{"data":{"markdownRemark":{"rawMarkdownBody":"# ES6 Standard\n\n## Learning objectives\n\n- Be able to read and write new ES6 standard\n\nThe language “JavaScript” follows certain standards, similar to how a spoken language has certain grammar. However, the JavaScript language has evolved a lot faster than a language such as English or French. While in the past the language evolved quite [sporadically](https://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning/). This is set to change with updates coming more frequently.\n\nOne of the newest standards for JavaScript - ES6 - was released in 2015. Since it always takes time to implement the new standards into different frameworks and environments, it is only now, that we are starting to really see the new conventions become the industry standards. However older browsers which aren’t updated anymore will be unable to understand the new JavaScript languages, which is why there are still a lot of people who write in previous standards.\n\n## Functions\n\nSo far we have declared functions with `function ()`. But in ES6 we use `() =>`\n\n```js\n// ES5\nfunction add(a, b) {\n  return a + b;\n}\n// ES6 = defines the function add, taking two inputs (a and b) and adds them together\nvar add = (a, b) => {\n  return a + b;\n};\n// shorten it even more\n// notice how `return` is omitted\nvar add = (a, b) => a + b;\n\n// shorten even more (slightly different code, we double one input here)\nvar double = a => a * 2;\n```\n\nAs you can see above, we can remove the curly brackets `{ }` if we only have one line of logic and if we don’t need a `return` statement either.\n\nIf we only have one parameter we don’t need to use the round brackets `( )` either. However if we have 0 or 2+ parameters we need to use the brackets.\n\nYou will notice that byusing ES6 we can write a lot less code - which some also call ‘clean code’. However, it can sometimes become too little, making it again difficult to understand.\n\n## Variables\n\nSo far we declared variables using the `var` statement. ES6 has two different variable declarations. For variables that won’t change we use `const`. For variables that will change throughout the code we use `let`. So `let` is just a replacement for `var`, whereas `const` is different in that it cannot be changed.\n\n```js\n// old way\nvar price = 2;\nvar revenue = 0;\n\nfunction revenue(sold) {\n  revenue = price * sold;\n}\n\n// ES6\nconst PRICE = 2;\nlet revenue = 0;\n\nconst revenue = sold => {\n  revenue = PRICE * sold;\n};\n```\n\nWhy should we use `const` at all? Imagine you have a lot of variable declarations, it becomes quickly very hard to tell what a variable is used for. Using `const` and `let` gives the reader the ability to better understand the purpose of a variable. Also using `const` prevents you from accidentally overwriting a variable.\n\nFor a deeper exploration of differences between var, let and const read this [article here](https://dev.to/sarah_chima/var-let-and-const--whats-the-difference-69e).\n\n## Object literals\n\nA JavaScript object literal is a comma-separated list of name-value pairs wrapped in curly braces. Object literals encapsulate data, enclosing it in a tidy package. This minimizes the use of global variables which can cause problems when combining code.\n\nThe following demonstrates an example object literal:\n\n```js\n// ES5\nfunction saveFile(file, data) {\n  return {\n    file: file,\n    data: data,\n    retrieve: function() {\n      // do something\n    }\n  };\n}\n\n// ES6\nfunction saveFile(file, data) {\n  return {\n    file,\n    data,\n    retrieve() {\n      // do something\n    }\n  };\n}\n```\n\nAs you can see if property name and property variable are the same (file, data) we only have to write them once. Equally we can get rid of the word function when declaring the retrieve method.\n\nAnother Example:\n\n```js\nvar myObject = {\n  sProp: 'some string value',\n  numProp: 2,\n  bProp: false\n};\n```\n\nObject literal property values can be of any data type, including array literals, functions, and nested object literals. Here is another object literal example with these property types:\n\n```js\nvar Swapper = {\n  // an array literal\n  images: ['smile.gif', 'grim.gif', 'frown.gif', 'bomb.gif'],\n  pos: {\n    // nested object literal\n    x: 40,\n    y: 300\n  },\n  onSwap: function() {\n    // function\n    // code here\n  }\n};\n```\n\n### Why and How We Use Object Literals\n\nSeveral JavaScripts from dyn-web use object literals for setup purposes. Object literals enable us to write code that supports lots of features yet still provide a relatively straightforward process for implementers of our code. There is no need to invoke constructors directly or maintain the correct order of arguments passed to functions.\n\nObject literals are also useful for unobtrusive event handling; they can hold the data that would otherwise be passed in function calls from HTML event handler attributes.\n\nThere is one drawback: if you are unfamiliar with the syntax, it can be very easy to cause errors which cause the code to stop working completely.\n\n## Destructuring\n\nES6 allows us to write even more concise code. If we want to pull some properties of objects and save them in variables, we can use destructuring.\n\nDestructuring is the opposite of data construction. Rather than constructing a new object or array, for example, destructuring takes data from an existing object or array and literally destructs it to extract only the values you’re interested in.\n\nIt does this through the use of a pattern that’s used by ES6 to match the values that you want to extract. This pattern mirrors the structure of the data item you’re destructuring, with only those parts of the data item that match the pattern, being extracted.\n\n```js\nvar books = {\n  title: 'Harry Potter',\n  author: 'J. K. Rowling'\n};\nvar names = ['Andy', 'Katie', 'Sam', 'Kay'];\n\n// ES5\n\nvar title = books.title;\nvar author = books.author;\nvar engineer = names[0];\nvar recruiter = names[1];\n\n// ES6\nconst { title, author } = books;\nconst [engineer, recruiter] = names;\n```\n\nFor the most in-depth yet understandable ES6 destructuring tutorial [head here](http://untangled.io/in-depth-es6-destructuring-with-assembled-avengers/).\n\n## Strings\n\nWriting long strings in ES6 is a lot easier than it used to be, especially when using \\`\\`, or backticks.\n\n```js\nfunction printInfo(firstName, lastName, age) {\n  // ES5\n  console.log(\n    'Hi I am ' +\n      firstName +\n      ', my last name is ' +\n      lastName +\n      '. I am ' +\n      age +\n      ' years old!'\n  );\n\n  // ES6 way\n  console.log(\n    `Hi I am ${firstName}, my last name is ${lastName}. I am ${age} years old!`\n  );\n}\n```\n\nInstead of using quotations marks `\" \"` we use backticks . No need for `+` and worry about putting all the space after variables. instead wrap all JS variables or logic in `${ }`. You can even put functions and complex logic in there.\n"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"fileAbsolutePath":"/Users/Andy/Desktop/code/PROJECTS/xccelerate/ptcb-site/src/data/week_1/es-6-standard.html.turndown.md","title":"es 6 standard"}}}